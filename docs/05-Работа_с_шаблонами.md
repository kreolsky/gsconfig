# Работа с шаблонами

Система шаблонов в GSConfig позволяет генерировать структурированные конфигурационные файлы на основе данных, полученных из Google Sheets. Шаблоны особенно полезны, когда требуется преобразовать данные в специфический формат для использования в игровых движках.

## Класс Template

`Template` - основной класс для работы с шаблонами. Он загружает шаблон из файла и заполняет его данными с помощью метода `render()`.

```python
class Template(object):
    def __init__(self, path='', body='', pattern=None, strip=True, jsonify=False):
        """
        Инициализация шаблона

        :param path: путь к файлу шаблона
        :param body: шаблон в виде строки (альтернатива path)
        :param pattern: паттерн для поиска переменных в шаблоне
        :param strip: отрезать ли кавычки от строк при подстановке
        :param jsonify: преобразовывать ли результат в JSON объект
        """
```

Пример использования:

### Шаблон из файла

Предположим, у нас есть шаблон `MobSettings.template`:

```json
{
  "_maxHealth": {health!float},
  "_timeToStartRegeneration": {time_before_regen!float},
  "_regenerationSpeed": {regen_speed!float},

  "_botRewards": {bot_rewards},

  "_massa": {weight!float},

  "MoveToPointSettings": { 
    "MaxSpeedWalk": {speed_walk_max!float},
    "MinSpeedWalk": {speed_walk_min!float}
  },

  "ChaoticPatrollingSettings": {
    "MaxIteration": 3,
    "MinIteration": 1,
    "MaxTimeStay": 3,
    "MinTimeStay": 1
  },
  "StraightPatrollingSettings": {
    "MaxIteration": 3,
    "MinIteration": 1,
    "MaxTimeStay": 3,
    "MinTimeStay": 1
  },
  "CowardlyStateSettings": {
    "MaxSpeedWalk": {speed_walk_max!float},
    "MinSpeedWalk": {speed_walk_min!float},
    "MaxSpeedRun": {speed_run_max!float},
    "MinSpeedRun": {speed_run_min!float}
  },
  "RectilinearCowardlyStateSettings": {
    "DelayCaptured": {captured_delay!int},
    "MaxSpeedRun": {speed_run_max!float},
    "MinSpeedRun": {speed_run_min!float},
    "Angle": {captured_angle!float},
    "Range": {captured_range!float}
  }
}
```

Код для загрузки и заполнения шаблона:

```python
import gsconfig

# Создание шаблона из файла
template = gsconfig.Template('templates/MobSettings.template')

# Данные для заполнения шаблона
data = {
    'health': 100,
    'time_before_regen': 5.0,
    'regen_speed': 1.5,
    'weight': 10.0,
    'speed_walk_max': 2.0,
    'speed_walk_min': 1.0,
    'speed_run_max': 4.0,
    'speed_run_min': 3.0,
    'captured_delay': 2,
    'captured_angle': 30.0,
    'captured_range': 5.0,
    'bot_rewards': {'gold': 10, 'exp': 5}
}

# Заполнение шаблона данными
result = template.render(data)

# Сохранение результата в файл
gsconfig.tools.save_json(result, 'SheepSettings', 'json')
```

### Шаблон из строки

Вы также можете передать шаблон напрямую в виде строки:

```python
import gsconfig

# Шаблон в виде строки
template_body = """
{
  "entityType": "Monster",
  "name": "{monster_name}",
  "stats": {
    "health": {health!float},
    "damage": {damage!int},
    "speed": {speed!float}
  },
  {% if has_drops %}
  "drops": [
  {% foreach drops %}
    {
      "item": "{$item!get_0}",
      "chance": {$item!get_1!float}
    },
  {% endforeach %}
  ]
  {% endif %}
}
"""

# Создание шаблона из строки
template = gsconfig.Template(body=template_body, jsonify=True)

# Данные для заполнения шаблона
data = {
    'monster_name': 'Goblin',
    'health': 50.5,
    'damage': 15.7,
    'speed': 3.2,
    'has_drops': True,
    'drops': [
        ['gold', 0.8],
        ['potion', 0.3],
        ['dagger', 0.1]
    ]
}

# Заполнение шаблона данными и получение результата как JSON
result = template.render(data)
print(result)
```

Результат:
```json
{
  "entityType": "Monster",
  "name": "Goblin",
  "stats": {
    "health": 50.5,
    "damage": 15,
    "speed": 3.2
  },
  "drops": [
    {
      "item": "gold",
      "chance": 0.8
    },
    {
      "item": "potion",
      "chance": 0.3
    },
    {
      "item": "dagger",
      "chance": 0.1
    }
  ]
}
```

## Команды в ключах шаблона

В шаблонах можно использовать команды для преобразования значений при подстановке. Команды указываются после ключа через символ `!`:

```
{key!command}
```

Например:
```
{health!float}
```

### Доступные команды

- **float** - преобразует значение в число с плавающей запятой
  ```
  {speed!float}  # 10 -> 10.0
  ```
- **int** - преобразует значение в целое число, отбрасывая дробную часть
  ```
  {health!int}  # 10.9 -> 10
  ```
- **json** - сохраняет структуру как JSON (применяет json.dumps())
  ```
  {stats!json}  # {"health": 100} -> "{\"health\": 100}"
  ```
- **extract** - извлекает элемент из списка, если это список единичной длины
  ```
  {item!extract}  # [{"name": "sword"}] -> {"name": "sword"}
  ```
- **wrap** - заворачивает в дополнительный список, если первый элемент не список
  ```
  {items!wrap}  # [1, 2, 3] -> [[1, 2, 3]]
  ```
- **string** - принудительно заворачивает строку в кавычки
  ```
  {name!string}  # John -> "John"
  ```
- **get_N** - получает элемент из списка по индексу N
  ```
  {items!get_2}  # ["a", "b", "c"] -> "c"
  ```

### Кастомные команды в ключах шаблона

См. раздел [Кастомные расширения](07-Кастомные_расширения.md)

## Команды управления строками шаблона

Шаблоны поддерживают специальные команды для управления строками:

### if

Сохраняет блок между `if` и `endif`, если условие истинно. Команда `if` обрабатывает только свой внутренний блок:

```json
{
  "character": {
    "base_stats": {
      "strength": {strength!int},
      "dexterity": {dexterity!int}
    },
    {% if has_weapon %}
    "weapon": {
      "name": "{weapon_name}",
      "damage": {weapon_damage!int}
    },
    {% endif %}
    "level": {level!int}
  }
}
```

Для данных:
```python
data = {
    'strength': 15,
    'dexterity': 12,
    'has_weapon': True,
    'weapon_name': 'Excalibur',
    'weapon_damage': 25.7,
    'level': 5
}
```

Результат будет:
```json
{
  "character": {
    "base_stats": {
      "strength": 15,
      "dexterity": 12
    },
    "weapon": {
      "name": "Excalibur",
      "damage": 25
    },
    "level": 5
  }
}
```

А если `has_weapon` будет `False`, то результат будет:
```json
{
  "character": {
    "base_stats": {
      "strength": 15,
      "dexterity": 12
    },
    "level": 5
  }
}
```

### foreach

Повторяет блок между `foreach` и `endforeach` для каждого элемента в списке. Команда `foreach` обрабатывает только свой внутренний блок, а окружающие структуры JSON должны быть расположены в основном шаблоне:

```json
{
  "monster": {
    "name": "Dragon",
    "drops": [
    {% foreach drops %}
      {
        "item": "{$item!get_0}",
        "chance": {$item!get_1!float},
        "count": {$item!get_2!int}
      },
    {% endforeach %}
    ]
  }
}
```

Для данных:
```python
data = {
    'drops': [
        ['sword', 0.5, 1],
        ['shield', 0.3, 1],
        ['potion', 0.7, 2]
    ]
}
```

Результат будет:
```json
{
  "monster": {
    "name": "Dragon",
    "drops": [
      {
        "item": "sword",
        "chance": 0.5,
        "count": 1
      },
      {
        "item": "shield",
        "chance": 0.3,
        "count": 1
      },
      {
        "item": "potion",
        "chance": 0.7,
        "count": 2
      }
    ]
  }
}
```

Команда `foreach` обходит элементы в списке, указанном в параметре (например, `drops`). Для итерации по элементам используется зарезервированная переменная `$item`, которая внутри блока заменяется на текущий элемент списка.

#### Особенности работы с переменной $item:

- Если элемент списка является простым типом (строка или число), то `$item` напрямую заменяется на значение этого элемента
  ```python
  # Если drops = ['sword', 'shield', 'potion']
  {% foreach drops %}
    "item_{$item}",  # Результат: "item_sword", "item_shield", "item_potion"
  {% endforeach %}
  ```

- Если элемент сложный (список или словарь), то `$item` заменяется конструкцией, позволяющей обратиться к элементу через индекс
  ```python
  # Если drops = [['sword', 0.5, 1], ['shield', 0.3, 1], ['potion', 0.7, 2]]
  {% foreach drops %}
    {
      "item": "{$item!get_0}",  # Обращение к первому элементу текущего вложенного списка
      "chance": {$item!get_1!float},
      "count": {$item!get_2!int}
    },
  {% endforeach %}
  ```

- Система автоматически удаляет последнюю запятую в генерируемом списке, что полезно при создании JSON-структур

### for

Повторяет блок между `for` и `endfor` заданное количество раз. Как и с командой `foreach`, команда `for` обрабатывает только свой внутренний блок:

```json
{
  "location": {
    "name": "Forest",
    "spawn_points": [
    {% for spawn_count %}
      {
        "x": {spawn_x!get_$i!float},
        "y": {spawn_y!get_$i!float},
        "z": {spawn_z!get_$i!float}
      },
    {% endfor %}
    ]
  }
}
```

Для данных:
```python
data = {
    'spawn_count': 3,
    'spawn_x': [10.5, 20.3, 15.7],
    'spawn_y': [5.1, 8.4, 3.2],
    'spawn_z': [1.0, 2.0, 1.5]
}
```

Результат будет:
```json
{
  "location": {
    "name": "Forest",
    "spawn_points": [
      {
        "x": 10.5,
        "y": 5.1,
        "z": 1.0
      },
      {
        "x": 20.3,
        "y": 8.4,
        "z": 2.0
      },
      {
        "x": 15.7,
        "y": 3.2,
        "z": 1.5
      }
    ]
  }
}
```

Команда `for` выполняет цикл заданное количество раз, определяемое числовым значением параметра (например, `spawn_count`). Внутри блока доступна зарезервированная переменная `$i`, которая содержит текущий индекс итерации.

#### Особенности использования переменной $i:

- Переменная `$i` принимает значения от 0 до n-1, где n - значение параметра `spawn_count`
  ```python
  # Если spawn_count = 3
  {% for spawn_count %}
    "position_{$i}",  # Результат: "position_0", "position_1", "position_2"
  {% endfor %}
  ```

- Переменная `$i` особенно полезна для доступа к элементам массивов по индексу:
  ```python
  # Если spawn_x = [10.5, 20.3, 15.7] и spawn_count = 3
  {% for spawn_count %}
    {
      "x": {spawn_x!get_$i!float},  # Получаем элемент из spawn_x с индексом 0, 1, 2
    },
  {% endfor %}
  ```

- Можно комбинировать несколько массивов для создания структурированных данных
  ```python
  # Если spawn_x = [10.5, 20.3, 15.7], spawn_y = [5.1, 8.4, 3.2], spawn_count = 3
  {% for spawn_count %}
    {
      "x": {spawn_x!get_$i!float},
      "y": {spawn_y!get_$i!float}
    },
  {% endfor %}
  ```

- Так же как и в случае с `foreach`, система автоматически удаляет последнюю запятую в генерируемом списке

## Комментарии в шаблонах

GSConfig поддерживает два способа добавления комментариев в шаблоны:

### Однострочные комментарии

Для добавления однострочных комментариев используется синтаксис:

```
{# Это комментарий, который будет удален при обработке шаблона #}
```

Пример использования однострочных комментариев:

```
{
  "_maxHealth": {health!float}, {# Максимальное здоровье моба #}
  "_timeToStartRegeneration": {time_before_regen!float}, {# Время до начала регенерации #}
  "_regenerationSpeed": {regen_speed!float} {# Скорость регенерации здоровья #}
}
```

### Многострочные комментарии

Для многострочных комментариев используется команда `comment`:

```
{% comment %}
Это многострочный комментарий,
который будет удален при обработке шаблона.
Удобно для временного отключения
больших блоков шаблона.
{% endcomment %}
```

Пример использования многострочных комментариев:

```
{
  "_mainSettings": {
    "health": {health!float},
    "speed": {speed!float}
  },
  
  {% comment %}
  Этот блок с дополнительными параметрами
  временно отключен, так как требует доработки
  "_additionalSettings": {
    "armor": {armor!float},
    "resistance": {resistance!float}
  },
  {% endcomment %}
  
  "_visualSettings": {
    "scale": {scale!float}
  }
}
```

Оба типа комментариев полностью удаляются в процессе обработки шаблона и не попадают в итоговый результат.

### Кастомные команды управления строками

См. раздел [Кастомные расширения](07-Кастомные_расширения.md)