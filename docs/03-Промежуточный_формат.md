# Промежуточный формат и конвертация

Одной из ключевых возможностей GSConfig является конвертация данных из "промежуточного формата", который удобен для заполнения в Google Sheets, в структурированный JSON, используемый в игровых системах.

## Формат данных

Промежуточный формат представляет собой упрощенную версию JSON с более гибким синтаксисом, который легче заполнять в таблицах. Вот основные особенности этого формата:

- **Упрощенный синтаксис** - меньше скобок и кавычек
- **Гибкие разделители** - возможность настраивать символы разделения блоков и элементов
- **Автоматическое определение типов** - числа и булевы значения преобразуются автоматически
- **Поддержка вложенных структур** - возможность создавать многоуровневые иерархии данных

Примеры записей в промежуточном формате и их JSON-эквиваленты:

```
# Простая запись ключ = значение
name = "Sheep", health = 100, speed = 1.5
```

Преобразуется в JSON:
```json
{
  "name": "Sheep",
  "health": 100,
  "speed": 1.5
}
```

```
# Вложенные структуры
stats = {health = 100, speed = 1.5}, drops = {wool = 3, meat = 2}, 
behavior = {idle_time = 5, run_speed = 3.0}
```

JSON с парсером v1 (словари заворачиваются в списки):
```json
{
  "stats": [
    {
      "health": 100,
      "speed": 1.5
    }
  ],
  "drops": [
    {
      "wool": 3,
      "meat": 2
    }
  ],
  "behavior": [
    {
      "idle_time": 5,
      "run_speed": 3.0
    }
  ]
}
```

JSON с парсером v2 (словари не заворачиваются):
```json
{
  "stats": {
    "health": 100,
    "speed": 1.5
  },
  "drops": {
    "wool": 3,
    "meat": 2
  },
  "behavior": {
    "idle_time": 5,
    "run_speed": 3.0
  }
}
```

```
# Списки значений
drop_items = {wool, meat, bone}, spawn_biomes = {plains, forest}
```

Преобразуется в JSON:
```json
{
  "drop_items": [
    "wool",
    "meat",
    "bone"
  ],
  "spawn_biomes": [
    "plains",
    "forest"
  ]
}
```

```
# Использование разделителей блоков для структурирования данных
0, 6| 7 = 7, zr = 0, one, tw = {2 = d}, tv = {2 = dv | 3 = tr} | a, b
```

Эта запись эквивалентна более сложной структуре:
```
{0, 6}, {7 = 7, zr = 0, one, tw = {2 = d}, tv = {{2 = dv}, {3 = tr}}}, {a, b}
```

Преобразуется в JSON (с парсером v2):
```json
[
    [
        0,
        6
    ],
    [
        "one",
        {
            "7": 7,
            "zr": 0,
            "tw": {
                "2": "d"
            },
            "tv": [
                {
                    "2": "dv"
                },
                {
                    "3": "tr"
                }
            ]
        }
    ],
    [
        "a",
        "b"
    ]
]
```

Этот пример наглядно показывает, как разделитель `|` позволяет записывать сложные вложенные структуры в более плоском и читаемом виде.

## ConfigJSONConverter

`ConfigJSONConverter` - класс, отвечающий за преобразование промежуточного формата в JSON. Он анализирует строки в промежуточном формате и создает соответствующие структуры данных Python (словари, списки, значения).

```python
class ConfigJSONConverter:
    def __init__(self, params={}):
        self.default_params = {
            'br_list': '[]',
            'br_block': '{}',
            'sep_func': '!',
            'sep_block': '|',
            'sep_base': ',',
            'sep_dict': '=',
            'raw_pattern': '"',
            'to_num': True,
            'parser_version': 'v1',
            'is_raw': False
        }
        self.params = {**self.default_params, **params}
        self.parser = BlockParser(self.params)

    def jsonify(self, string: str, is_raw: bool = False) -> dict | list:
        """
        Метод переводящий строку конфига в JSON
        - string -- исходная строка для конвертации
        - is_raw -- в случае True строка не будет конвертироваться и возвращается как есть
        """
```

## Параметры конвертера

При создании `ConfigJSONConverter` можно настроить различные параметры для изменения поведения конвертера:

```python
params = {
    'br_list': '[]',        # Тип скобок для списков
    'br_block': '{}',       # Тип скобок для блоков
    'sep_func': '!',        # Разделитель для функций
    'sep_block': '|',       # Разделитель блоков
    'sep_base': ',',        # Основной разделитель элементов
    'sep_dict': '=',        # Разделитель ключ-значение
    'raw_pattern': '"',     # Символ для сырых строк
    'to_num': True,         # Преобразовывать ли строки в числа
    'parser_version': 'v2', # Версия парсера
    'is_raw': False         # Нужно ли парсить строку
}

converter = gsconfig.ConfigJSONConverter(params)
```

**Важно!** Не рекомендуется изменять значение `br_list` по умолчанию, так как это может привести к ошибкам парсинга.

## Версии конвертера

В GSConfig есть две версии конвертера, которые отличаются поведением при обработке словарей:

### v1 (по умолчанию)
- Все словари всегда заворачиваются в список
- Пример: `five = {three = 3, two = 2}` превращается в `{"five": [{"three": 3, "two": 2}]}`

### v2
- Разворачивает списки единичной длины
- Для заворачивания в список нужно явно указать команду `!list` или использовать синтаксический сахар `[]`
- Пример: `five = {three = 3, two = 2}` превращается в `{"five": {"three": 3, "two": 2}}`
- Пример с явным заворачиванием: `five!list = {three = 3, two = 2}` или `five[] = {three = 3, two = 2}`

## Команды парсера

В промежуточном формате можно использовать специальные команды для управления преобразованием данных:

### Команды для v2
- **list** - заворачивает содержимое в список только если это не список
  ```
  items!list = {sword, shield, potion}
  ```
- **dlist** - заворачивает только словари в список
  ```
  stats!dlist = {health = 100, mana = 50}
  ```
- **flist** - всегда заворачивает в дополнительный список, даже списки
  ```
  nested!flist = {{1, 2}, {3, 4}}
  ```

### Короткие команды (синтаксический сахар)
- **[]** - эквивалентно `!dlist`
  ```
  stats[] = {health = 100, mana = 50}
  ```
- **()** - эквивалентно `!list`
  ```
  items() = {sword, shield, potion}
  ```
- **{}** - эквивалентно `!flist`
  ```
  nested{} = {{1, 2}, {3, 4}}
  ```
